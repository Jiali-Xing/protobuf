Total: 90ms
ROUTINE ======================== github.com/tgiannoukos/charon.(*PriceTable).UpdatePricebyQueueDelay in /go/pkg/mod/github.com/tgiannoukos/charon@v0.0.0-20231221071202-0347470ae6a2/tokenAndPrice.go
      10ms       20ms (flat, cum) 22.22% of Total
         .          .    131:func (pt *PriceTable) UpdatePricebyQueueDelay(ctx context.Context) error {
         .          .    132:	ownPrice_string, _ := pt.priceTableMap.Load("ownprice")
         .          .    133:	ownPrice := ownPrice_string.(int64)
         .          .    134:
         .          .    135:	// read the gapLatency from context ctx
         .          .    136:	gapLatency := ctx.Value("gapLatency").(float64)
         .          .    137:	// Calculate the priceStep as a fraction of the difference between gapLatency and latencyThreshold
         .          .    138:
         .          .    139:	diff := int64(gapLatency*1000) - pt.latencyThreshold.Microseconds()
         .          .    140:	adjustment := pt.calculatePriceAdjustment(diff)
         .          .    141:
      10ms       10ms    142:	logger("[Update Price by Queue Delay]: Own price %d, step %d\n", ownPrice, adjustment)
         .          .    143:
         .          .    144:	ownPrice += adjustment
         .          .    145:	// Set reservePrice to the larger of pt.guidePrice and 0
         .          .    146:	reservePrice := int64(math.Max(float64(pt.guidePrice), 0))
         .          .    147:
         .          .    148:	if ownPrice <= reservePrice {
         .          .    149:		ownPrice = reservePrice
         .          .    150:	}
         .          .    151:
         .          .    152:	pt.priceTableMap.Store("ownprice", ownPrice)
         .       10ms    153:	logger("[Update Price by Queue Delay]: Own price updated to %d\n", ownPrice)
         .          .    154:
         .          .    155:	return nil
         .          .    156:}
         .          .    157:
         .          .    158:// UpdatePricebyQueueDelayExp uses exponential function to adjust the price step.
ROUTINE ======================== github.com/tgiannoukos/charon.(*PriceTable).queuingCheck in /go/pkg/mod/github.com/tgiannoukos/charon@v0.0.0-20231221071202-0347470ae6a2/overloadDetection.go
         0       40ms (flat, cum) 44.44% of Total
         .          .     35:func (pt *PriceTable) queuingCheck() {
         .          .     36:	// init a null histogram
         .          .     37:	var prevHist *metrics.Float64Histogram
         .          .     38:	for range time.Tick(pt.priceUpdateRate) {
         .          .     39:		// start a timer to measure the query latency
         .          .     40:		start := time.Now()
         .          .     41:		// get the current histogram
         .          .     42:		currHist := readHistogram()
         .          .     43:		/*
         .          .     44:			// calculate the differernce between the two histograms prevHist and currHist
         .          .     45:			diff := metrics.Float64Histogram{}
         .          .     46:			// if preHist is empty pointer, return currHist
         .          .     47:			if prevHist == nil {
         .          .     48:				diff = *currHist
         .          .     49:			} else {
         .          .     50:				diff = GetHistogramDifference(*prevHist, *currHist)
         .          .     51:			}
         .          .     52:			// maxLatency is the max of the histogram in milliseconds.
         .          .     53:			gapLatency := maximumBucket(&diff)
         .          .     54:		*/
         .          .     55:		if prevHist == nil {
         .          .     56:			// directly go to next iteration
         .          .     57:			prevHist = currHist
         .          .     58:			continue
         .          .     59:		}
         .          .     60:		gapLatency := maximumQueuingDelayms(prevHist, currHist)
         .          .     61:		// medianLatency := medianBucket(&diff)
         .          .     62:		// gapLatency := percentileBucket(&diff, 90)
         .          .     63:
         .          .     64:		ctx := context.Background()
         .          .     65:
         .          .     66:		// ToDo: move the print of the histogram to a file
         .          .     67:		/*
         .          .     68:			cumulativeLat := medianBucket(currHist)
         .          .     69:			// printHistogram(currHist)
         .          .     70:			logger("[Cumulative Waiting Time Median]:	%f ms.\n", cumulativeLat)
         .          .     71:			// printHistogram(&diff)
         .          .     72:			logger("[Incremental Waiting Time 90-tile]:	%f ms.\n", percentileBucket(&diff, 90))
         .          .     73:			logger("[Incremental Waiting Time Median]:	%f ms.\n", medianBucket(&diff))
         .          .     74:			logger("[Incremental Waiting Time Maximum]:	%f ms.\n", maximumBucket(&diff))
         .          .     75:		*/
         .          .     76:		logger("[Incremental Waiting Time Maximum]:	%f ms.\n", gapLatency)
         .          .     77:		// store the gapLatency in the context ctx
         .          .     78:		ctx = context.WithValue(ctx, "gapLatency", gapLatency)
         .          .     79:
         .          .     80:		if pt.priceStrategy == "step" {
         .          .     81:			pt.UpdateOwnPrice(pt.overloadDetection(ctx))
         .          .     82:		} else if pt.priceStrategy == "proportional" {
         .       20ms     83:			pt.UpdatePricebyQueueDelay(ctx)
         .          .     84:		} else if pt.priceStrategy == "exponential" {
         .          .     85:			pt.UpdatePricebyQueueDelayExp(ctx)
         .          .     86:		} else if pt.priceStrategy == "log" {
         .          .     87:			pt.UpdatePricebyQueueDelayLog(ctx)
         .          .     88:		}
         .          .     89:		// copy the content of current histogram to the previous histogram
         .          .     90:		prevHist = currHist
         .          .     91:		// log the time elapsed for the query
         .       20ms     92:		logger("[Query Latency]:	Overhead is %.2f milliseconds\n", float64(time.Since(start).Microseconds())/1000)
         .          .     93:	}
         .          .     94:}
         .          .     95:
         .          .     96:// throughputCheck decrements the counter by 2x every x milliseconds.
         .          .     97:func (pt *PriceTable) throughputCheck() {
ROUTINE ======================== github.com/tgiannoukos/charon.logger in /go/pkg/mod/github.com/tgiannoukos/charon@v0.0.0-20231221071202-0347470ae6a2/logger.go
         0       30ms (flat, cum) 33.33% of Total
         .          .      9:func logger(format string, a ...interface{}) {
         .          .     10:	if debug {
         .          .     11:		timestamp := time.Now().Format("2006-01-02T15:04:05.999999999-07:00")
         .       30ms     12:		fmt.Printf("LOG: "+timestamp+"|\t"+format+"\n", a...)
         .          .     13:	}
         .          .     14:}
