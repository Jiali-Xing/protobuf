Total: 130ms
ROUTINE ======================== github.com/tgiannoukos/charon.(*PriceTable).queuingCheck in /go/pkg/mod/github.com/tgiannoukos/charon@v0.0.0-20231016025447-7c2c4e5003cd/overloadDetection.go
         0       30ms (flat, cum) 23.08% of Total
         .          .     37:func (pt *PriceTable) queuingCheck() {
         .          .     38:	// init a null histogram
         .          .     39:	var prevHist *metrics.Float64Histogram
         .          .     40:	for range time.Tick(pt.priceUpdateRate) {
         .          .     41:		// start a timer to measure the query latency
         .          .     42:		start := time.Now()
         .          .     43:		// get the current histogram
         .       10ms     44:		currHist := readHistogram()
         .          .     45:		/*
         .          .     46:			// calculate the differernce between the two histograms prevHist and currHist
         .          .     47:			diff := metrics.Float64Histogram{}
         .          .     48:			// if preHist is empty pointer, return currHist
         .          .     49:			if prevHist == nil {
         .          .     50:				diff = *currHist
         .          .     51:			} else {
         .          .     52:				diff = GetHistogramDifference(*prevHist, *currHist)
         .          .     53:			}
         .          .     54:			// maxLatency is the max of the histogram in milliseconds.
         .          .     55:			gapLatency := maximumBucket(&diff)
         .          .     56:		*/
         .          .     57:		if prevHist == nil {
         .          .     58:			// directly go to next iteration
         .          .     59:			prevHist = currHist
         .          .     60:			continue
         .          .     61:		}
         .          .     62:		gapLatency := maximumQueuingDelayms(prevHist, currHist)
         .          .     63:		// medianLatency := medianBucket(&diff)
         .          .     64:		// gapLatency := percentileBucket(&diff, 90)
         .          .     65:
         .       10ms     66:		ctx := metadata.NewIncomingContext(context.Background(), metadata.Pairs("request-id", "0"))
         .          .     67:
         .          .     68:		// ToDo: move the print of the histogram to a file
         .          .     69:		/*
         .          .     70:			cumulativeLat := medianBucket(currHist)
         .          .     71:			// printHistogram(currHist)
         .          .     72:			pt.logger(ctx, "[Cumulative Waiting Time Median]:	%f ms.\n", cumulativeLat)
         .          .     73:			// printHistogram(&diff)
         .          .     74:			pt.logger(ctx, "[Incremental Waiting Time 90-tile]:	%f ms.\n", percentileBucket(&diff, 90))
         .          .     75:			pt.logger(ctx, "[Incremental Waiting Time Median]:	%f ms.\n", medianBucket(&diff))
         .          .     76:			pt.logger(ctx, "[Incremental Waiting Time Maximum]:	%f ms.\n", maximumBucket(&diff))
         .          .     77:		*/
         .          .     78:		pt.logger(ctx, "[Incremental Waiting Time Maximum]:	%f ms.\n", gapLatency)
         .          .     79:		// store the gapLatency in the context ctx
         .       10ms     80:		ctx = context.WithValue(ctx, "gapLatency", gapLatency)
         .          .     81:
         .          .     82:		if pt.priceStrategy == "step" {
         .          .     83:			pt.UpdateOwnPrice(ctx, pt.overloadDetection(ctx))
         .          .     84:		} else if pt.priceStrategy == "proportional" {
         .          .     85:			pt.UpdatePricebyQueueDelay(ctx)
ROUTINE ======================== github.com/tgiannoukos/charon.readHistogram in /go/pkg/mod/github.com/tgiannoukos/charon@v0.0.0-20231016025447-7c2c4e5003cd/queuingDelay.go
         0       10ms (flat, cum)  7.69% of Total
         .          .    133:func readHistogram() *metrics.Float64Histogram {
         .          .    134:	// Create a sample for metric /sched/latencies:seconds and /sync/mutex/wait/total:seconds
         .          .    135:	const queueingDelay = "/sched/latencies:seconds"
         .          .    136:	measureMutexWait := false
         .          .    137:
         .          .    138:	// Create a sample for the metric.
         .       10ms    139:	sample := make([]metrics.Sample, 1)
         .          .    140:	sample[0].Name = queueingDelay
         .          .    141:	if measureMutexWait {
         .          .    142:		const mutexWait = "/sync/mutex/wait/total:seconds"
         .          .    143:		sample[1].Name = mutexWait
         .          .    144:	}
