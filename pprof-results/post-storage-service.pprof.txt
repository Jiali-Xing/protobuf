Total: 100ms
ROUTINE ======================== github.com/tgiannoukos/charon.(*PriceTable).queuingCheck in /go/pkg/mod/github.com/tgiannoukos/charon@v0.0.0-20231016025447-7c2c4e5003cd/overloadDetection.go
         0       20ms (flat, cum) 20.00% of Total
         .          .     37:func (pt *PriceTable) queuingCheck() {
         .          .     38:	// init a null histogram
         .          .     39:	var prevHist *metrics.Float64Histogram
         .          .     40:	for range time.Tick(pt.priceUpdateRate) {
         .          .     41:		// start a timer to measure the query latency
         .          .     42:		start := time.Now()
         .          .     43:		// get the current histogram
         .       20ms     44:		currHist := readHistogram()
         .          .     45:		/*
         .          .     46:			// calculate the differernce between the two histograms prevHist and currHist
         .          .     47:			diff := metrics.Float64Histogram{}
         .          .     48:			// if preHist is empty pointer, return currHist
         .          .     49:			if prevHist == nil {
ROUTINE ======================== github.com/tgiannoukos/charon.readHistogram in /go/pkg/mod/github.com/tgiannoukos/charon@v0.0.0-20231016025447-7c2c4e5003cd/queuingDelay.go
         0       20ms (flat, cum) 20.00% of Total
         .          .    133:func readHistogram() *metrics.Float64Histogram {
         .          .    134:	// Create a sample for metric /sched/latencies:seconds and /sync/mutex/wait/total:seconds
         .          .    135:	const queueingDelay = "/sched/latencies:seconds"
         .          .    136:	measureMutexWait := false
         .          .    137:
         .          .    138:	// Create a sample for the metric.
         .          .    139:	sample := make([]metrics.Sample, 1)
         .          .    140:	sample[0].Name = queueingDelay
         .          .    141:	if measureMutexWait {
         .          .    142:		const mutexWait = "/sync/mutex/wait/total:seconds"
         .          .    143:		sample[1].Name = mutexWait
         .          .    144:	}
         .          .    145:
         .          .    146:	// Sample the metric.
         .       20ms    147:	metrics.Read(sample)
         .          .    148:
         .          .    149:	// Check if the metric is actually supported.
         .          .    150:	// If it's not, the resulting value will always have
         .          .    151:	// kind KindBad.
         .          .    152:	if sample[0].Value.Kind() == metrics.KindBad {
